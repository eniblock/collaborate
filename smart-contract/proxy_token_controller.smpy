import smartpy as sp

rule_type = sp.TRecord(
    template_id = sp.TNat,
    authorized_builders = sp.TSet(sp.TString) # group names
)

template_type = sp.TRecord(
    contract_threshold = sp.TNat,
    groups = sp.TMap(sp.TString, sp.TRecord(group_threshold = sp.TNat, group_weight = sp.TNat))
)

update_groups_type = sp.TList(
    sp.TVariant(
            add = sp.TMap(sp.TString, sp.TAddress),
            remove = sp.TMap(sp.TString, sp.TAddress)
    )
)
update_templates_type = sp.TList(
    sp.TVariant(
            update = sp.TMap(sp.TNat, template_type),
            remove = sp.TList(sp.TNat)
    )
)
update_rules_type = sp.TList(
    sp.TVariant(
            update = sp.TMap(sp.TString, rule_type),
            remove = sp.TList(sp.TString)
    )
)

contract_metadata_type = sp.TRecord(
    k = sp.TString,
    v= sp.TBytes
    )

operator_param_type = sp.TRecord(
    owner = sp.TAddress,
    operator = sp.TAddress,
    token_id = sp.TNat
    )

update_operators_params_type = sp.TList(
    sp.TVariant(
        add_operator = operator_param_type,
        remove_operator = operator_param_type
        )
    )

transfer_type = sp.TRecord(
    from_ = sp.TAddress,
    txs = sp.TList(
        sp.TRecord(
            to_ = sp.TAddress,
            token_id = sp.TNat,
            amount = sp.TNat
            ).layout(("to_", ("token_id", "amount")))
        )
    ).layout(("from_", "txs"))

transfer_params_type = sp.TList(transfer_type)

batch_mint_params_type = sp.TRecord(
    metadata_links = sp.TList(sp.TBytes),
    first_token_id = sp.TNat,
    address = sp.TAddress
    )

token_metadata_type = sp.TMap(sp.TString, sp.TBytes)

mint_params_type = sp.TRecord(
    token_id = sp.TNat, 
    amount = sp.TNat, 
    address = sp.TAddress,
    metadata = token_metadata_type
    )

multisig_build_params_type = sp.TRecord(
    multisig_id = sp.TString,
    signers = sp.TList(sp.TAddress),
    build_and_sign = sp.TBool,
    call_params = sp.TRecord(
        target_address = sp.TAddress,
        entry_point = sp.TString,
        adr1 = sp.TAddress,
        adr2 = sp.TAddress,
        bytes_list = sp.TList(sp.TBytes),
        str_bytes_map = token_metadata_type,
        nbr1 = sp.TNat,
        nbr2 = sp.TNat,
        str = sp.TString,
        bytes = sp.TBytes,
        bl = sp.TBool # Conf variable, ex : update operator
        )
    )


class ProxyTokenController(sp.Contract):
    def __init__(self, proxy_admins, groups, multisig_templates, rules):
        self.init(
            proxy_admins = sp.set(proxy_admins),
            multisigs = sp.big_map(),
            #nb_multisigs = @TODO consecutive?!?
            groups = sp.map(
                l = groups, 
                tkey = sp.TString, 
                tvalue = sp.TSet(sp.TAddress)
            ),
            multisig_templates = sp.map(
                l = multisig_templates, 
                tkey = sp.TNat, 
                tvalue = template_type
            ),
            rules = sp.map(
                l = rules, 
                tkey = sp.TString, # entrypoint
                tvalue = rule_type
            )
        )

    @sp.entry_point
    def update_groups(self, params: update_groups_type):
        sp.verify(self.data.proxy_admins.contains(sp.sender), "senderIsNotAuthorized")
        # TODO verify that TAG supports Variants
        sp.for updates in params:
            with updates.match_cases() as arg:
                with arg.match("add") as upd:
                    sp.for elt in upd.items():
                        self.data.groups[elt.key].add(elt.value)    
                with arg.match("remove") as upd:
                    sp.for elt in upd.items():
                        self.data.groups[elt.key].remove(elt.value)    

    @sp.entry_point
    def update_templates(self, params: update_templates_type):
        sp.verify(self.data.proxy_admins.contains(sp.sender), "senderIsNotAuthorized")
        # TODO verify that TAG supports Variants
        sp.for updates in params:
            with updates.match_cases() as arg:
                with arg.match("update") as upd:
                    sp.for elt in upd.items():
                        self.data.multisig_templates[elt.key] = elt.value
                with arg.match("remove") as upd:
                    sp.for elt in upd:
                        del self.data.multisig_templates[elt.key]

    @sp.entry_point
    def update_rules(self, params: update_groups_type):
        sp.verify(self.data.proxy_admins.contains(sp.sender), "senderIsNotAuthorized")
        # TODO verify that TAG supports Variants
        sp.for updates in params:
            with updates.match_cases() as arg:
                with arg.match("update") as upd:
                    sp.for elt in upd.items():
                        self.data.groups[elt.key] = elt.value    
                with arg.match("remove") as upd:
                    sp.for elt in upd:
                        del self.data.groups[elt.key]


    def _is_builder(self, sender: sp.TAddress, authorized_builders: sp.TSet(sp.TString)):
        # empty set means that any one can build 
        sp.if sp.len(authorized_builders) != 0:
            authorized = sp.local('authorized', False)
            sp.for group in authorized_builders.elements():
                sp.verify(self.data.groups.contains(group), "UnknownGroup")
                sp.for adr in self.data.groups[group].elements():
                    sp.if sender == adr:
                        authorized.value = True
            sp.verify(authorized.value, "NotAuthorizedBuilder")
                
    # define a multisig contract
    @sp.entry_point
    def build(self, params: multisig_build_params_type):
        sp.verify(self.data.rules.contains(params.call_params.entry_point), "UnknownEntryPoint")
        sp.verify(~self.data.multisigs.contains(params.multisig_id), "InvalidMultisigId")

        sp.verify(self.data.rules.contains(params.call_params.entry_point), "NoRuleForThisEntrypoint")
        rule = self.data.rules[params.call_params.entry_point]
        self._is_builder(sp.sender, rule.authorized_builders)

        sp.verify(self.data.multisig_templates.contains(rule.template_id), "UnknownTemplate")
        rule_template = self.data.multisig_templates[rule.template_id]
        
        participants = sp.local('participants', sp.list([]))
        groups = sp.local('groups', sp.list([]))
        sp.for group in rule_template.groups.items():
        # empty string group means participants are passed in parameters
            sp.if group.key == "": 
                sp.for signer in params.signers:
                    participants.value.push(sp.record(hasVoted = False, id = signer))
            sp.else:  
                sp.for signer in self.data.groups[group.key].elements():
                    participants.value.push(sp.record(hasVoted = False, id = signer))                
            groups.value.push(sp.record(
                participants = participants.value,
                votes = 0,
                ok = False,
                group_threshold = group.value.group_threshold, 
                group_weight = group.value.group_weight
            ))
            participants.value = sp.list([])

        contract = sp.record(
             weight          = 0,
             contract_threshold = rule_template.contract_threshold,
             groups          = groups.value,
             ok              = False,
             call_params      = params.call_params
            )
        self.data.multisigs[params.multisig_id] = contract
        sp.if params.build_and_sign:
            self._sign(sp.record(contractId = params.multisig_id, id = sp.sender))

    # sign a multisig contract
    @sp.entry_point
    def sign(self, params):
        sp.verify(params.id == sp.sender, "InvalidSender")
        self._sign(params)

    def _sign(self, params):
        id = params.id
        contractId = params.contractId
        contract = self.data.multisigs[contractId]
        sp.for group in contract.groups:
            sp.for participant in group.participants:
                sp.if participant.id == id:
                    sp.verify(~ participant.hasVoted, "ParticipantAlreadyVoted")
                    participant.hasVoted = True
                    group.votes += 1
                    sp.if ~group.ok & (group.group_threshold <= group.votes):
                        group.ok = True
                        contract.weight += group.group_weight
                        sp.if ~contract.ok & (contract.contract_threshold <= contract.weight):
                            contract.ok = True
                            self.onOK(contract.call_params)


    def onOK(self, params):
        sp.if params.entry_point == "mint":
            self._call_mint(params)
        sp.if params.entry_point == "update_operators":
            self._call_update_operators(params)
        sp.if params.entry_point == "transfer":
            self._call_transfer(params)
        sp.if params.entry_point == "set_pause":
            self._call_set_pause(params)
        sp.if params.entry_point == "set_metadata":
            self._call_set_metadata(params)
        sp.if params.entry_point == "set_administrator":
            self._call_set_administrator(params)
        sp.if params.entry_point == "batch_mint":
            self._call_batch_mint(params)



    def _call_mint(self, params):
        parameters = sp.record(
            token_id = params.nbr1, 
            address = params.adr1,
            amount = params.nbr2,
            metadata = params.str_bytes_map
            )
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(mint_params_type, params.target_address, entry_point = "mint").open_some()
        )

        # add operator along with the mint
        sp.if params.bl == True: 
            add_op_parameters = [
                sp.variant("add_operator", sp.record(
                    owner = params.adr1,
                    operator = params.adr2,
                    token_id = params.nbr1
                ))
            ]
            sp.transfer(
                add_op_parameters,
                sp.tez(0),
                sp.contract(update_operators_params_type, params.target_address, entry_point = "update_operators").open_some()
            )
            
    def _call_update_operators(self, params):
        parameters = [
                sp.variant("add_operator", sp.record(
                    owner = params.adr1,
                    operator = params.adr2,
                    token_id = params.nbr1
                ))
            ]
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(update_operators_params_type, params.target_address, entry_point = "update_operators").open_some()
        )

    def _call_transfer(self, params):
        parameters = [
            sp.record(
                from_ = params.adr1,
                txs = [
                    sp.record(
                        to_ = params.adr2,
                        token_id = params.nbr1,
                        amount = params.nbr2
                    )
                ]
            )
        ]
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(transfer_params_type, params.target_address, entry_point = "transfer").open_some()
        )

    def _call_set_pause(self, params):
        parameters = params.bl
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(sp.TBool, params.target_address, entry_point = "set_pause").open_some()
        )

    def _call_set_metadata(self, params):
        parameters = sp.record(k = params.str, v = params.bytes)
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(contract_metadata_type, params.target_address, entry_point = "set_metadata").open_some()
        )

    def _call_set_administrator(self, params):
        parameters = params.adr1
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(sp.TAddress, params.target_address, entry_point = "set_administrator").open_some()
        )

    def _call_batch_mint(self, params):
        parameters = sp.record(
            first_token_id = params.nbr1, 
            address = params.adr1,
            metadata_links = params.bytes_list
        )
        sp.transfer(
            parameters,
            sp.tez(0),
            sp.contract(batch_mint_params_type, params.target_address, entry_point = "batch_mint").open_some()
        )
        # add operator along with the batch_mint
        sp.if params.bl == True: 
            add_op_parameters = sp.local('add_op_parameters', sp.list([]))
            sp.for token_id in sp.range(params.nbr1, params.nbr1 + sp.len(params.bytes_list), step = 1):
                add_op_parameters.value.push(sp.variant("add_operator", sp.record(
                    owner = params.adr1,
                    operator = params.adr2,
                    token_id = token_id
                )))
            sp.transfer(
                add_op_parameters.value,
                sp.tez(0),
                sp.contract(update_operators_params_type, params.target_address, entry_point = "update_operators").open_some()
            )


# Tests
@sp.add_test(name = "ProxyTokenController")
def test():

    scenario = sp.test_scenario()

    super_fa2_admin1 = sp.address("tz1PxztX893wouZdQmGVARX5c31Cbor354fv")
    super_fa2_admin2 = sp.address("tz1R5Sd63TCC37g9wxEe8g3JQ3GYEq1oAv5j")

    super_minter1 = sp.address("tz1Tz45dBEsM5RDXCaj1Ut4ay6ZyHKamUBvT")
    super_minter2 = sp.address("tz1YjCQ9ATce6gJHTnmn7zZaBaLLWqKNcqdK")
    
    minter1 = sp.address("tz1XWbzEHXfuEMKR4Vs6ewDMFnKa8VoApVdK")
    minter2 = sp.address("tz1XxrCBL7RyKFKMMvMG5CHmbc1ubVr7ehHm")

    alice = sp.address("tz1YmbuUQagUMY8AycZuvHyf8zm8sgPCMYgG")

    batch_minter = sp.address("tz1bwp2oXPzdHYVzn6cpsmehehdcUuF2Bgk5")

    proxy_admin = sp.address("tz1caQoK6ZVwg6CVakpJo14nM43UhoG7TZ9J")

    multisig_builder = proxy_admin

    target = sp.address("KT1aDD7H3WgbFgd7YeMn8UbqQeMXJ96kxvD5")

    groups = {
        "super_fa2_admins": sp.set([super_fa2_admin1, super_fa2_admin2]),
        "super_minters": sp.set([super_minter1, super_minter2]),
        "minters": sp.set([minter1, minter2]),
        "batch_minters": sp.set([batch_minter]),
        "multisig_builders": sp.set([multisig_builder])
        }

    multisig_templates = {
        0: sp.record(
                contract_threshold = 1,
                groups = {
                    "super_fa2_admins": sp.record(group_threshold = 1, group_weight = 1)
                }
            ),
        1: sp.record(
                contract_threshold = 3,
                groups = {
                    "super_minters": sp.record(group_threshold = 1, group_weight = 1),
                    "minters": sp.record(group_threshold = 2, group_weight = 1),
                    "": sp.record(group_threshold = 1, group_weight = 2)
                }
            ),
        2: sp.record(
                contract_threshold = 1,
                groups = {
                    "batch_minters": sp.record(group_threshold = 1, group_weight = 1)
                }
            )
    }

    rules = {
        "mint": sp.record(
            template_id = 1,
            authorized_builders = sp.set(["multisig_builders"])
        ),
        "batch_mint": sp.record(
            template_id = 2,
            authorized_builders = sp.set(["multisig_builders", "batch_minters"])
        ),
        "set_administrator": sp.record(
            template_id = 0,
            authorized_builders = sp.set(["super_fa2_admins"])
        ),
        "update_operators": sp.record(
            template_id = 0,
            authorized_builders = sp.set(["super_fa2_admins"])
        ),
        "transfer": sp.record(
            template_id = 0,
            authorized_builders = sp.set(["super_fa2_admins"])
        ),
        "set_pause": sp.record(
            template_id = 0,
            authorized_builders = sp.set(["super_fa2_admins"])
        ),
        "set_metadata": sp.record(
            template_id = 0,
            authorized_builders = sp.set([]) # in order to test if anyone can build when the list is empty
        )
    }
    
    #PCC
    ## put the real initiator parameters, the contract will be initially deployed with the following parameters
    c0 = ProxyTokenController(
        [proxy_admin], 
        groups, 
        multisig_templates,
        rules
        )
    scenario += c0
    
    # DigitalPassport
    scenario += c0.build(
        build_and_sign = False,
        multisig_id = "0000",
        signers = [alice], # Owner
        call_params = sp.record(
            target_address = target,
            entry_point = "mint",
            adr1 = alice, # Owner
            adr2 = super_minter1, # Operator
            bytes_list = [],
            str_bytes_map = {"": sp.bytes("0x050100000035697066733a2f2f516d5a36584762695a4d77664454325066436e71747462426e564d4a727473397670636867575251544b33337762")},
            nbr1 = 0,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = True
        )
    ).run(sender = multisig_builder)
    scenario += c0.sign(id = alice, contractId = "0000").run(sender = alice)
    scenario += c0.sign(id = super_minter1, contractId = "0000").run(sender = super_minter1)
    
    # DATA Catalog
    scenario += c0.build(
        multisig_id = "1111",
        build_and_sign = True,
        signers = [],
        call_params = sp.record(
            target_address = target,
            entry_point = "batch_mint",
            adr1 = alice,
            adr2 = minter2,
            bytes_list = [
                sp.bytes("0x050100000035697066733a2f2f516d5a36584762695a4d77664454325066436e71747462426e564d4a727473397670636867575251544b33337762"),
                sp.bytes("0x050200000035697066733a2f2f516d5a36584762695a4d77664454325066436e71747462426e564d4a727473397670636867575251544b33337762")
            ],
            str_bytes_map = {},
            nbr1 = 1,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = True
        )
    ).run(sender = batch_minter)

    # CREATE 

    scenario += c0.build(
        multisig_id = "2222",
        build_and_sign = False,
        signers = [], 
        call_params = sp.record(
            target_address = target,
            entry_point = "batch_mint",
            adr1 = alice,
            adr2 = minter2,
            bytes_list = [
                sp.bytes("0x050100000035697066733a2f2f516d5a36584762695a4d77664454325066436e71747462426e564d4a727473397670636867575251544b33337762"),
                sp.bytes("0x050200000035697066733a2f2f516d5a36584762695a4d77664454325066436e71747462426e564d4a727473397670636867575251544b33337762")
            ],
            str_bytes_map = {},
            nbr1 = 0,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = False
        )
    ).run(sender = batch_minter)

    # Non authorized builder
    scenario += c0.build(
        multisig_id = "3333",
        build_and_sign = True,
        signers = [], 
        call_params = sp.record(
            target_address = target,
            entry_point = "transfer",
            adr1 = alice, 
            adr2 = minter2, 
            bytes_list = [],
            str_bytes_map = {},
            nbr1 = 0,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = False
        )
    ).run(sender = alice, valid = False)

    scenario += c0.build(
        multisig_id = "3333",
        build_and_sign = True,
        signers = [], 
        call_params = sp.record(
            target_address = target,
            entry_point = "transfer",
            adr1 = alice, 
            adr2 = minter2, 
            bytes_list = [],
            str_bytes_map = {},
            nbr1 = 0,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = False
        )
    ).run(sender = super_fa2_admin1)
 
    # anyone can build when the list is empty

    scenario += c0.build(
        multisig_id = "4444",
        build_and_sign = False,
        signers = [], 
        call_params = sp.record(
            target_address = target,
            entry_point = "set_metadata",
            adr1 = alice, 
            adr2 = minter2, 
            bytes_list = [],
            str_bytes_map = {},
            nbr1 = 0,
            nbr2 = 1,
            bytes = sp.bytes("0x"),
            str = "",
            bl = False
        )
    )

    # Test groups, templates and rules update
    # @TODO
